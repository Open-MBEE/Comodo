/* 
 * This code was generated by Comodo (https://github.com/Open-MBEE/Comodo) 
 * using the QPC-C Target Platform
 *
 * - Generated Class (Comodo Module):
 *      blinkyChoice
 *
 * - Generated State Machine (Comodo Component):
 *      orthogonal
 * 
 *
 * ############### Requirements ###############
 *  Implements: 
 * - https://<traceability-service-hostname>/724776 
 * - https://<traceability-service-hostname>/724777 
 *
 * ############################################
 *
 */


 
#include <stdio.h>
#include <string.h>
#include <log_event.h>
#include <assert.h>
#include <blinkyChoice_orthogonal.h>
#include <blinkyChoice_orthogonal_impl.h>




// Orthogonal regions initialized here
orthogonalState_region1 orthogonalState_region1_inst;
orthogonalState_region2 orthogonalState_region2_inst;



/**
 * blinkyChoice_orthogonal Constructor
 */
blinkyChoice_orthogonal *blinkyChoice_orthogonal_constructor (blinkyChoice_orthogonal *me, const char *objNameNew, blinkyChoice_orthogonal_impl *implObj, QActive *active) {
    QActive_ctor((QActive *)me, (QStateHandler )&blinkyChoice_orthogonal_initial);
    strncpy(me->objName, objNameNew, 128);
    strncat(me->objName, ":blinkyChoice_orthogonal", 128-strlen(me->objName));
    me->impl = implObj;
    if (0 == active) {  // self IS the active object
        me->active = (QActive *)me;
    } else {  // set containing machine as active object
        me->active = active;
    }
    blinkyChoice_orthogonal_impl_set_qactive(me->impl, me->active);  // give impl access to parent QActive

    // Timer events initialized here
    QTimeEvt_ctor(&(me->state2RelativeTimer), STATE2_TIMER_SIG);

    // Orthogonal regions initialized here
    me->region1 = &orthogonalState_region1_inst;
    (void)orthogonalState_region1_constructor(me->region1, me->impl, me->active, me);
    me->region2 = &orthogonalState_region2_inst;
    (void)orthogonalState_region2_constructor(me->region2, me->impl, me->active, me);


    // State is initially at TOP
    me->myState = BLINKYCHOICE_ORTHOGONAL__TOP__;

    return me;
}

blinkyChoice_orthogonal_impl *blinkyChoice_orthogonal_get_impl (blinkyChoice_orthogonal *me) {
    return me->impl;
}

blinkyChoice_orthogonal_state blinkyChoice_orthogonal_get_current_state (blinkyChoice_orthogonal *me) {
    return me->myState;
}

/**
 * initial state definition
 */
QState blinkyChoice_orthogonal_initial (blinkyChoice_orthogonal *me, QEvt const *e) {
    // Subscribe to all the signals to which this state machine needs to respond.
	if (me->active == (QActive *)me) {
		QActive_subscribe(me->active, BLINKYCHOICE_TURN_OFF_SIG);
		QActive_subscribe(me->active, BLINKYCHOICE_TURN_ON_SIG);
		QActive_subscribe(me->active, BLINKYCHOICE_WIF_HEY_SIG);
		QActive_subscribe(me->active, _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_);
	}

    return Q_TRAN(&blinkyChoice_orthogonal_init);
}

/**
 * init state definition
 */
QState blinkyChoice_orthogonal_init (blinkyChoice_orthogonal *me, QEvt const *e) {
    switch (e->sig) {
        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_INIT;
            return Q_HANDLED();

        case Q_EXIT_SIG:
            return Q_HANDLED();

        case BLINKYCHOICE_WIF_HEY_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState);


    }
    return Q_SUPER(&QHsm_top);
}

/**
 * orthogonalState state definition
 */
QState blinkyChoice_orthogonal_orthogonalState (blinkyChoice_orthogonal *me, QEvt const *e) {
    switch (e->sig) {
        case BLINKYCHOICE_TURN_ON_SIG:
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region1), e);
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region2), e);

            return Q_HANDLED();

        case STATE2_TIMER_SIG:
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region2), e);

            return Q_HANDLED();

        case BLINKYCHOICE_TURN_OFF_SIG:
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region1), e);

            return Q_HANDLED();

        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE;
            QF_ACTIVE_INIT_((QHsm *)(me->region1), e);
            QF_ACTIVE_INIT_((QHsm *)(me->region2), e);

            return Q_HANDLED();

        case Q_EXIT_SIG:
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region1),
                                        &(me->BLINKYCHOICE_ORTHOGONAL_BAIL_EVENT_));
            orthogonalState_region1_reinit(me->region1);
            QF_ACTIVE_DISPATCH_((QHsm *)(me->region2),
                                        &(me->BLINKYCHOICE_ORTHOGONAL_BAIL_EVENT_));
            orthogonalState_region2_reinit(me->region2);

            return Q_HANDLED();

        case BLINKYCHOICE_TURN_OFF_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_init);


    }
    return Q_SUPER(&QHsm_top);
}

// ############ Utility method definitions for orthogonal region: orthogonalState_region1 ############

/** 
 * Orthogonal-region constructor for orthogonalState_region1
 */
orthogonalState_region1 *orthogonalState_region1_constructor (orthogonalState_region1 *me, const char *objNameNew, blinkyChoice_orthogonal_impl *implObj, QActive *active, blinkyChoice_orthogonal *parent) {
    QHsm_ctor((QHsm *)me, (QStateHandler )orthogonalState_region1_initial);
    strncpy(me->objName, objNameNew, 128);
    me->objName[128-1] = '\0';  // null-terminate string
    me->impl = implObj;
    me->active = active;
    me->parent = parent;

    // State is initially at TOP
    me->myState = BLINKYCHOICE_ORTHOGONAL__TOP__;

    return me;
}

blinkyChoice_orthogonal_state orthogonalState_region1_get_current_state (orthogonalState_region1 *me) {
    return me->myState;
}

void orthogonalState_region1_reinit (orthogonalState_region1 *me) {
    ((QHsm *)me)->state = (QStateHandler ) &orthogonalState_region1_initial;
}

// ############ State handler methods definitions for orthogonal region: orthogonalState_region1 ############

/**
 * Initial transition of the state machine (equivalent to initial pseudostate node)
 * This routine handles initial events of the state-machine.
 */
QState blinkyChoice_orthogonal_orthogonalState_region1_initial (orthogonalState_region1 *me, QEvt const *e) {
    return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region1_state1);
}

QState blinkyChoice_orthogonal_orthogonalState_region1_final (orthogonalState_region1 *me, QEvt const *e) {
    switch (e->sig) {
    case Q_ENTRY_SIG:
        me->myState = BLINKYCHOICE_ORTHOGONAL__TOP__;
        return Q_HANDLED();
    case Q_EXIT_SIG:
        return Q_HANDLED();
    case Q_BAIL_SIG:  // prevents dropped event if submachine already terminated
        return Q_HANDLED();
    }
    return Q_SUPER(&QHsm_top);
}

/**
 * state1 state definition
 */
QState blinkyChoice_orthogonal_orthogonalState_region1_state1 (orthogonalState_region1 *me, QEvt const *e) {
    switch (e->sig) {
        case Q_BAIL_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region1_final);

        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_REGION1_STATE1;
            return Q_HANDLED();

        case Q_EXIT_SIG:
            return Q_HANDLED();

        case BLINKYCHOICE_TURN_OFF_SIG:

            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.super.sig = _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_;
            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.substate = NULL;  // Comodo functionality not implemented
            QF_publish_(&(me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.base_evt));
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region1_finalState0);

        case BLINKYCHOICE_TURN_ON_SIG:

            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.super.sig = _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_;
            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.substate = NULL;  // Comodo functionality not implemented
            QF_publish_(&(me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.base_evt));
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region1_finalState0);


    }
    return Q_SUPER(&blinkyChoice_orthogonal_orthogonalState);
}

/**
 * finalState0 state definition
 */
QState blinkyChoice_orthogonal_orthogonalState_region1_finalState0 (orthogonalState_region1 *me, QEvt const *e) {
    switch (e->sig) {
        case _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_:
            return Q_HANDLED();

        case Q_BAIL_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region1_final);

        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_REGION1_FINALSTATE0;
            return Q_HANDLED();

        case Q_EXIT_SIG:
            return Q_HANDLED();


    }
    return Q_SUPER(&blinkyChoice_orthogonal_orthogonalState);
}

// ############ Utility method definitions for orthogonal region: orthogonalState_region2 ############

/** 
 * Orthogonal-region constructor for orthogonalState_region2
 */
orthogonalState_region2 *orthogonalState_region2_constructor (orthogonalState_region2 *me, const char *objNameNew, blinkyChoice_orthogonal_impl *implObj, QActive *active, blinkyChoice_orthogonal *parent) {
    QHsm_ctor((QHsm *)me, (QStateHandler )orthogonalState_region2_initial);
    strncpy(me->objName, objNameNew, 128);
    me->objName[128-1] = '\0';  // null-terminate string
    me->impl = implObj;
    me->active = active;
    me->parent = parent;

    // State is initially at TOP
    me->myState = BLINKYCHOICE_ORTHOGONAL__TOP__;

    return me;
}

blinkyChoice_orthogonal_state orthogonalState_region2_get_current_state (orthogonalState_region2 *me) {
    return me->myState;
}

void orthogonalState_region2_reinit (orthogonalState_region2 *me) {
    ((QHsm *)me)->state = (QStateHandler ) &orthogonalState_region2_initial;
}

// ############ State handler methods definitions for orthogonal region: orthogonalState_region2 ############

/**
 * Initial transition of the state machine (equivalent to initial pseudostate node)
 * This routine handles initial events of the state-machine.
 */
QState blinkyChoice_orthogonal_orthogonalState_region2_initial (orthogonalState_region2 *me, QEvt const *e) {
    return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region2_state2);
}

QState blinkyChoice_orthogonal_orthogonalState_region2_final (orthogonalState_region2 *me, QEvt const *e) {
    switch (e->sig) {
    case Q_ENTRY_SIG:
        me->myState = BLINKYCHOICE_ORTHOGONAL__TOP__;
        return Q_HANDLED();
    case Q_EXIT_SIG:
        return Q_HANDLED();
    case Q_BAIL_SIG:  // prevents dropped event if submachine already terminated
        return Q_HANDLED();
    }
    return Q_SUPER(&QHsm_top);
}

/**
 * state2 state definition
 */
QState blinkyChoice_orthogonal_orthogonalState_region2_state2 (orthogonalState_region2 *me, QEvt const *e) {
    switch (e->sig) {
        case Q_BAIL_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region2_final);

        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_REGION2_STATE2;
            QTimeEvt_postIn(&(me->state2RelativeTimer), me->active, 8s);
            return Q_HANDLED();

        case Q_EXIT_SIG:
            QTimeEvt_disarm(&(me->state2RelativeTimer));
            return Q_HANDLED();

        case STATE2_TIMER_SIG:

            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.super.sig = _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_;
            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.substate = NULL;  // Comodo functionality not implemented
            QF_publish_(&(me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.base_evt));
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region2_finalState1);

        case BLINKYCHOICE_TURN_ON_SIG:
            blinkyChoice_orthogonal_impl_do_this(me->impl, EHH);
            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.super.sig = _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_;
            me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.completion_evt.substate = NULL;  // Comodo functionality not implemented
            QF_publish_(&(me->BLINKYCHOICE_ORTHOGONAL_COMPLETION_EVENT_.base_evt));
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region2_finalState1);


    }
    return Q_SUPER(&blinkyChoice_orthogonal_orthogonalState);
}

/**
 * finalState1 state definition
 */
QState blinkyChoice_orthogonal_orthogonalState_region2_finalState1 (orthogonalState_region2 *me, QEvt const *e) {
    switch (e->sig) {
        case _SIG_BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_COMPLETE_:
            return Q_HANDLED();

        case Q_BAIL_SIG:
            return Q_TRAN(&blinkyChoice_orthogonal_orthogonalState_region2_final);

        case Q_ENTRY_SIG:
            me->myState = BLINKYCHOICE_ORTHOGONAL_ORTHOGONALSTATE_REGION2_FINALSTATE1;
            return Q_HANDLED();

        case Q_EXIT_SIG:
            return Q_HANDLED();


    }
    return Q_SUPER(&blinkyChoice_orthogonal_orthogonalState);
}
