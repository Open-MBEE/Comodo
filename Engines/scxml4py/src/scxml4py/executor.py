'''
    executor module part of scxml4py.
    
    @authors: landolfa
    @date: 2016-12-29
    
    @copyright: LGPL 2.1 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
    02111-1307 USA.
'''

'''
    $Id: event.py 1061 2015-07-13 15:03:59Z landolfa $
'''

import logging
import functools
import scxml4py.helper
from enum import Enum
from queue import Queue
from scxml4py.event import EventStatus
from scxml4py.state import HistoryType, StateAtomic, StateParallel, StateCompound, StateHistory


class EventHandlingPolicy(Enum):
    SILENT = 0
    REJECT = 1
    DEFFERRED = 2


class Executor(object):
    
    def __init__(self, theStateMachine, theContext, externalEventQueue = None, internalEventQueue = None):
        self.mStateMachine = theStateMachine
        self.mContext = theContext
        self.mEventHandlingPolicy = EventHandlingPolicy.SILENT
        self.mEventListeners = list()
        self.mStatusListeners = list()
        self.mCurrentStatus = set()
        self.mPreviousStatus = set()
        self.mStatesToInvoke = set()
        if internalEventQueue == None:
            self.mInternalEvents = Queue()
        else:
            self.mInternalEvents = internalEventQueue
        if externalEventQueue == None:
            self.mExternalEvents = Queue()
        else:
            self.mExternalEvents = externalEventQueue
        self.mContinue = False # is interpreted started
        self.mFinal = False    # is top level final state reached

    def getStatus(self):
        return self.mCurrentStatus
    
    def getModel(self):
        return self.mStateMachine    

    def getContext(self):
        return self.mContext
    
    def getEventHandlingPolicy(self):
        return self.mEventHandlingPolicy

    def isRunning(self):
        return self.mContinue

    def isFinal(self):
        return self.mFinal
    
    def isEventProcessable(self, e):
        """
        Check wheter an event enables transitions or not.
        This method can be used to implement event processing
        policy such as: 
        - SILENT simply ignore the event
        - REJECT return an error message
        - DEFERRED leave the event in the queue until it can be process
         """
        enabledTransitions = self.selectTransitions(e)
        return enabledTransitions.__len__() > 0

    def start(self):
        """
        First perform in-place expansions of states by including
        SCXML source referenced by URLs (see 3.13 Referencing External Files)
        and change initial attributes to initial container children with empty
        transitions to the state from the attribute.
        
        @TODO
        expandScxmlSource(doc)
        
        Then (optionally) validate the resulting SCXML, and throw an
        exception if validation fails.
        @TODO
        if !(valid(doc)) {fail with error}
        """
        logging.getLogger("scxml4py").debug("Starting execution of <" + self.mStateMachine.getId() + ">")
        self.mContinue = True
        self.mFinal = False

        """
        Call executeTransitionContent on the initial transition that is a
        child of scxml. Then call enterState on the initial transition.
        
        Finally, start the interpreter's event loop.
        """

        # Transition initalTrans = mStateMachine.getInitialTrans();
        # List<Transition> transList = new LinkedList<Transition>();
        # transList.add(initalTrans);

        transList = self.mStateMachine.getInitialTrans()
        if transList.__len__() == 0:
            # @TODO: throw exception no INITIAL state defined!
            return
    
        # cout << endl << "EXEC Initial Transition:" << endl;
        # mHelper.printTransitions(transList);
        self.executeTransitionContent(transList)
        self.enterStates(transList)

        """
        Upon entering the state machine, we take all internally enabled transitions,
        namely those that don't require an event and those that are triggered by
        internal events. (Internal events can only be generated by the state machine itself.)
        When all such transitions have been taken, we move to the main event loop,
        which is driven by external events.
        """
        initialStepComplete = False
        while initialStepComplete == False:
            enabledTransitions = self.selectEventlessTransitions();
            if enabledTransitions.__len__() == 0:
                if self.mInternalEvents.empty() == False:
                    # need to wait?
                    internalEvent = self.mInternalEvents.get_nowait()
                    #datamodel.assignValue("event", internalEvent)
                    enabledTransitions = self.selectTransitions(internalEvent)
            if enabledTransitions.__len__() > 0:
                self.microstep(enabledTransitions)
            else:
                initialStepComplete = True
        self.notifyStatusListeners(self.mCurrentStatus)

    def stop(self): 
        logging.getLogger("scxml4py").debug("Stopping execution of <" + self.mStateMachine.getId() + ">")
        self.mContinue = False
        self.exitInterpreter()
        self.mCurrentStatus.clear()
        self.mPreviousStatus.clear()
        with self.mInternalEvents.mutex:
            self.mInternalEvents.queue.clear()
        with self.mExternalEvents.mutex:
            self.mExternalEvents.queue.clear()

    def postEvent(self, theEvent):
        logging.getLogger("scxml4py").debug("Adding event <" + theEvent.getId() + "> to the external queue")
        # @TODO: check the timeout option
        self.mExternalEvents.put(theEvent, True, 2) 

    def processEvent(self, theEvent):
        logging.getLogger("scxml4py").debug("Adding event <" + theEvent.getId() + "> to the external queue")
        # @TODO: check the timeout option
        self.mExternalEvents.put(theEvent, True, 2) 
        self.processEvents()
        
    def processEvents(self):
        """
     * This loop runs until we enter a top-level final state or an external
     * entity cancels processing.
     * In either case 'continue' will be set to false (see EnterStates, below,
     * for termination by entering
     * a top-level final state.)
     *
     * Each iteration through the loop consists of three main steps:
     * 1) execute any <invoke> tags for atomic states that we entered on the
     *    last iteration through the loop
     * 2) Wait for an external event and then execute any transitions that it triggers
     * 3) Take any subsequent internally enabled transitions, namely those that
     *    don't require an event or that
     *    are triggered by an internal event.
     *
     * This event loop thus enforces run-to-completion semantics, in which the
     * system process an external event and then takes all the 'follow-up'
     * transitions that the processing has enabled before looking for another
     * external event.
     * For example, suppose that the external event queue contains events e1 and
     * e2 and the machine is in state s1. If processing e1 takes the machine to
     * s2 and generates internal event e3, and s2 contains a transition t triggered
     * by e3, the system is guaranteed to take t, no matter what transitions
     * s2 or other states have that would be triggered by e2. Note that this is
     * true even though e2 was already in the external event queue when e3 was
     * generated. In effect, the algorithm treats the processing of e3 as
     * finishing up the processing of e1.
     */

        replaced while loop with processEvent method which has to be called
        by the client every time there is an external event. This allows the
        client to implement the event loop
        """
        if self.mContinue == False:
            # @TODO throw exception: SM not started
            logging.getLogger('scxml4py').debug("Events cannot be processed because execution has been stopped")
            return

        # run until no events are left in the queues and no eventless transitions are enabled
        while self.mExternalEvents.empty() == False or self.mInternalEvents.empty() == False:
            # this call should/could blocks until an event is available
            if self.mExternalEvents.empty() == False:
                # @TODO with or without timeout?
                externalEvent = self.mExternalEvents.get_nowait()
                self.mContext.setLastEvent(externalEvent)
                logging.getLogger("scxml4py").debug("Processing external event <" + externalEvent.getId() + ">")

                # @TODO
                # datamodel.assignValue("event",externalEvent)
                enabledTransitions = self.selectTransitions(externalEvent)
                if enabledTransitions.__len__() > 0:
                    self.microstep(enabledTransitions)
                    # now take any newly enabled null transitions
                    # and any transitions triggered by internal events
                    self.processInternalEvents()
                    externalEvent.setStatus(EventStatus.PROCESSED);
                else:
                    if self.getEventHandlingPolicy() == EventHandlingPolicy.REJECT:
                        externalEvent.setStatus(EventStatus.REJECTED)
                    else:
                        externalEvent.setStatus(EventStatus.IGNORED)
                self.notifyEventListeners(externalEvent)
            if self.mInternalEvents.empty() == False:
                self.processInternalEvents()
            # Note that invokation may rise internal events.
            for s in self.mStatesToInvoke:
                if type(s) == StateAtomic:
                    s.startActivities()
            self.mStatesToInvoke.clear()
            self.mPreviousStatus = self.mCurrentStatus


    def processInternalEvents(self): 
        macroStepCompleted = False
        while macroStepCompleted == False:
            enabledTransitions = self.selectEventlessTransitions()
            if enabledTransitions.__len__() == 0:
                if self.mInternalEvents.empty() == False:
                    # @TODO do we need a timeout?
                    internalEvent = self.mInternalEvents.get_nowait()
                    #mInternalEvents.pop();
                    assert(internalEvent != None)
                    self.mContext.setLastEvent(internalEvent)
                    logging.getLogger("scxml4py").debug("Processing internal event <" + internalEvent.getId() + ">")
                    # @TODO
                    #datamodel.assignValue("event", internalEvent)
                    enabledTransitions = self.selectTransitions(internalEvent);
                else:
                    macroStepCompleted = True    
            if enabledTransitions.__len__() != 0:
                self.microstep(enabledTransitions)

    def exitInterpreter(self):
        """
        The purpose of this procedure is to exit the current SCXML process
        by exiting all active states.
        If the machine is in a top-level final state, a Done event is generated.
        """
        inFinalState = False
        statesToExit = scxml4py.helper.getAncestorsList(self.mCurrentStatus)
        # sort statesToExit in exitOrder
        statesToExit.sort(key=functools.cmp_to_key(scxml4py.helper.compareStates), reverse=True)
        for s in statesToExit:
            s.getExitActions().execute(self.mContext)
            s.cancelActivities()
            if s.isFinal() == True and s.getParent() == None:
                inFinalState = True
                
        self.mCurrentStatus.clear()

        if inFinalState:
            # @TODO
            # sendDoneEvent(???);
            pass

    def selectEventlessTransitions(self):
        """
        This function selects all transitions that are enabled in the current
        configuration that do not require an event trigger.
        First test if the state has been preempted by a transition that has
        already been selected and that will cause the state to be exited when
        the transition is taken. If the state has not been preempted, find a
        transition with no 'event' attribute whose condition evaluates to true.
        If multiple matching transitions are present, take the first in document
        order. If none are present, search in the state's ancestors in ancestory
        order until one is found. As soon as such a transition is found, add it
        to enabledTransitions, and proceed to the next atomic state in the
        configuration. If no such transition is found in the state or its ancestors,
        proceed to the next state in the configuration. When all atomic states have
        been visited and transitions selected, return the set of enabled transitions.
        """
        enabledTransitions = list()
        atomicStates = scxml4py.helper.getAtomicStates(self.mCurrentStatus)
        for s in atomicStates:
            if scxml4py.helper.isPreempted(s, enabledTransitions) == False:
                ancestors = scxml4py.helper.getAncestorsList([s])
                # order ancestors in exitOrder
                ancestors.sort(key=functools.cmp_to_key(scxml4py.helper.compareStates), reverse=True)
                for a in ancestors:
                    transitions = a.getTransitions()
                    for t in transitions:
                        if t.isEnabled(self.mContext) == True:
                            enabledTransitions.append(t)                           
        logging.getLogger("scxml4py").debug("Selected event-less transitions:\n" + scxml4py.helper.formatTransitions(enabledTransitions))
        return enabledTransitions
 
    def selectTransitions(self, e):
        """
        The purpose of the selectTransitions() procedure is to collect
        the transitions that are enabled by this event in the current
        configuration.
        Create an empty set of enabledTransitions.
        For each atomic state in the configuration, first check
        if the event is the result of an <invoke> in this state.
        If so, apply any <finalize> code in the state.
        Next test if the state has been preempted by a transition that
        has already been selected and that will cause the state to be
        exited when the transition is taken. If the state has not been
        preempted, find a transition whose 'event' attribute matches event
        and whose condition evaluates to true. If multiple matching transitions
        are present, take the first in document order. If none are present,
        search in the state's ancestors in ancestory order until one is found.
        As soon as such a transition is found, add it to enabledTransitions,
        and proceed to the next atomic state in the configuration.
        If no such transition is found in the state or its ancestors,
        proceed to the next state in the configuration.
        When all atomic states have been visited and transitions selected,
        return the set of enabled transitions.
        """
        enabledTransitions = list()
        atomicStates = scxml4py.helper.getAtomicStates(self.mCurrentStatus)
        for s in atomicStates:
            """
            @TODO
            event is the result of an <invoke> in this state
            if (event.attribute('invokeid') != null && state.invokeid = event.invokeid) {
                applyFinalize(state, event);
            }
            """
            if scxml4py.helper.isPreempted(s, enabledTransitions) == False:
                ancestors = scxml4py.helper.getAncestorsList([s])
                # order ancestors in exitOrder
                ancestors.sort(key=functools.cmp_to_key(scxml4py.helper.compareStates), reverse=True)
                foundTrans = False
                for a in ancestors:
                    transList = a.getTransitions()
                    for t in transList:
                        if t.isEnabled(self.mContext, e) == True:
                            """
                            Care has to be taken not to add the SAME transition more than once.
                            Consider the case of 2 active substates (orthogonal regions) and a
                            common superstate with internal transition or self-transition:
                            the transition should NOT be executed twice (one per region)!
                            """
                            #if (t in enabledTransitions) == False:
                            if scxml4py.helper.isTransitionInList(t, enabledTransitions) == False:
                                enabledTransitions.append(t)
                                foundTrans = True
                                break
                    """
                    one transition has been found, proceed with the next
                    atomic state in the configuration.
                    """
                    if foundTrans == True:
                        break;
        logging.getLogger("scxml4py").debug("Selected transitions on event <" + e.getId() + ">:\n" + scxml4py.helper.formatTransitions(enabledTransitions))
        return enabledTransitions

    def microstep(self, enabledTransitions):
        """
        The purpose of the microStep procedure is to process the set of transitions
        enabled by an external event, an internal event, or by the presence or absence
        of certain values in the dataModel at the current point in time.
        The processing of the enabled transitions must be done in parallel ('lock step')
        in the sense that their source states must first be exited, then their actions must
        be executed, and finally their target states entered.
        """
        self.exitStates(enabledTransitions)
        self.executeTransitionContent(enabledTransitions)
        self.enterStates(enabledTransitions)

    def exitStates(self, enabledTransitions):
        """
        Create an empty statesToExit set.
    
        For each transition t in enabledTransitions, if t is targetLess then do nothing,
        else let LCA be the least common ancestor state of the source state and target states of t.
        Add to the statesToExit set all states in the configuration that are descendants of LCA.
        Convert the statesToExit set to a list and sort it in exitOrder.
    
        For each state s in the list, if s has a deep history state h, set the history value
        of h to be the list of all atomic descendants of s that are members in the current
        configuration, else set its value to be the list of all immediate children of s that
        are members of the current configuration.
    
        Again for each state s in the list, first execute any onExit handlers, then cancel any
        ongoing invocations, and finally remove s from the current configuration.

        procedure exitStates(enabledTransitions):
            statesToExit = new Set()
            for t in enabledTransitions:
               if (t.attribute('target') != null):
                  LCA = findLCA([t.parent()].append(getTargetStates(t)))
                  for s in configuration.toList():
                     if (isDescendant(s,LCA)):
                        statesToExit.add(s)
            statesToExit = statesToExit.toList().sort(exitOrder)
            for s in statesToExit:
               for h in s.history:
                  f = (h.attribute('type') == "deep") ?
                      lambda(s0): isAtomicState(s0) && isDescendant(s0,s) :
                      lambda(s0): s0.parent() == s
                  historyValue[h.attribute('id')] = configuration.toList().filter(f)
            for s in statesToExit:
               for content in s.onexit:
                  executeContent(content)
               for inv in s.invoke:
                  cancelInvoke(inv)
               configuration.delete(s)
        """
        statesToExit = list()
        for t in enabledTransitions:
            targets = t.getTargets()
            if targets.__len__() > 0:
                LCA = scxml4py.helper.findLeastCommonAncestor(t.getSource(), targets[0])
                for s in self.mCurrentStatus:
                    if s.isDescendantFrom(LCA) == True:
                        statesToExit.append(s)        
                # self transition specified with target state -> change of state required
                if t.getSource() == targets[0] and t.getSource() != None:
                    statesToExit.append(t.getSource())

        # Remove from the list of activities to start the ones related to states to be exited
        for s in statesToExit:
            if scxml4py.helper.isStateInList(s, self.mStatesToInvoke) == True:
                self.mStatesToInvoke.remove(s)

        # sort the exit states in reverse order (nested states first)
        statesToExit.sort(key=functools.cmp_to_key(scxml4py.helper.compareStates), reverse=True)
    
        # Update history stack (if any).
        for s in statesToExit:
            h = s.getHistory()
            if h != None:
                for s0 in self.mCurrentStatus:
                    if h.getHistoryType() == HistoryType.DEEP:
                        if type(s0) == StateAtomic and s0.isDescendantFrom(s):
                            h.pushHistoryValue(s0)
                    else:
                        assert(h.getHistoryType() == HistoryType.SHALLOW)
                        if s0.getParent() == s:
                            h.pushHistoryValue(s0)
                            
        # finally exit the states by executing the exit actions
        for s in statesToExit:
            logging.getLogger('scxml4py').debug("Exiting state <" + s.getId() + "> (" + s.getType().__str__() + ")")
            s.getExitActions().execute(self.mContext)
            s.cancelActivities()
            self.mCurrentStatus.remove(s)

    def executeTransitionContent(self, enabledTransitions):
        # For each transition in the list of enabledTransitions, execute its executable content.
        for t in enabledTransitions:
            t.getActions().execute(self.mContext)

    def enterStates(self, enabledTransitions):
        statesToEnter = list()
        statesForDefaultEntry = list()

        # Build a list of the states to enter.
        for t in enabledTransitions:
            targets = t.getTargets()
            if targets.__len__() > 0:
                # @TODO should be LCA between source and all targets !!! TOBEFIXED
                # LCA = findLCA([t.parent()].append(getTargetStates(t)))
                LCA = scxml4py.helper.findLeastCommonAncestor(t.getSource(), targets[0])
                self.addStatesToEnter(targets[0], LCA, statesToEnter, statesForDefaultEntry)

        # Reset history state after entering states containing history.
        for s in statesToEnter:
            h = s.getHistory()
            if h != None:
                h.clearHistoryValues()

        # Update current status and execute entry and initial transition actions.
        statesToEnter.sort(key=functools.cmp_to_key(scxml4py.helper.compareStates), reverse=False)
        for s in statesToEnter:
            self.mCurrentStatus.add(s)
            self.mStatesToInvoke.add(s)

            """
            After updating the current status with the entering states and
            before executing the entry actions, notify the listener on the
            change of state. This allows the listener to get the new state
            configuration before for example a reply is sent by an entry 
            action (for example an ONLINE command which changes states from
            STANDBY to ONLINE: the reply should be sent after the notification
            has been done.
            """
            self.notifyStatusListeners(self.mCurrentStatus)
            logging.getLogger("scxml4py").debug("Entering state <"+s.getId()+">")
            s.getEntryActions().execute(self.mContext)
            
            #if s in statesForDefaultEntry == True:
            if scxml4py.helper.isStateInList(s, statesForDefaultEntry) == True:
                # @TODO
                #executeContent(s.initial.transition.children())
                initTrans = s.getInitialTrans()
                for t in initTrans:
                    t.getActions().execute(self.mContext)
    
            # if s is a final state, generate relevant Done events
            if s.isFinal() == True:
                #State parent = s.getParent();
                #State grandparent = parent.getParent();
                # @TODO
                """
                doneEvent = Event(parent.getId()+".Done", Event.EventType.CHANGE_EVENT);
                mInternalEvents.add(doneEvent);
                if (grandparent.isParallel() == true) {
                    List<State> substates = grandparent.getSubstates();
                    for (Iterator<State> it1 = substates.iterator(); it1.hasNext();) {
                            State s1 = it1.next();
                        if (isInFinalState(s) == true) {
                                    Event doneEvent1 = new Event(s1.getParent().getId()+".Done", Event.EventType.CHANGE_EVENT);
                        mInternalEvents.add(doneEvent1);
                            }
                    }
                }
                """
                    
            # If we have reached a top-level final state, exit the interpreter.
            for s in self.mCurrentStatus:
                if s.isFinal() == True and s.getParent() == None:
                    self.mFinal = True;
                    # self.mContinue = False
                    logging.getLogger('scxml4py').debug("enterStates: reached top-level final state -> mFinal = true")


    def addStatesToEnter(self, s, root, statesToEnter, statesForDefaultEntry): 
        assert(s != None)
        # 'root' can be NULL
        #logging.getLogger('scxml4py').debug("State to enter: <" + s.getId() + "> (" + s.getType().__str__() + ")")    
        if type(s) == StateHistory:
            # transition to history state
            values = s.getHistoryValues()
            if values.__len__() > 0:
                # Add the states in the history stack to the list of states to enter.
                for h in values:
                    self.addStatesToEnter(h, root, statesToEnter, statesForDefaultEntry)
            else:
                # If history stack is empty, take the (mandatory) transition from
                # the history state to a default initial state.
                transitions = s.getTransitions()
                for t in transitions:
                    targets = t.getTargets()
                    for target in targets:
                        self.addStatesToEnter(target, root, statesToEnter, statesForDefaultEntry)
        else:
            statesToEnter.append(s)
            if type(s) == StateParallel:
                # if it is a parallel state, than we need to enter in each region
                substates = s.getSubstates()
                for substate in substates:
                    self.addStatesToEnter(substate, s, statesToEnter, statesForDefaultEntry)
            elif type(s) == StateCompound:
                # if it is a composite state we need to resolve the initial pseudo-state
                statesForDefaultEntry.append(s)
                if s.getInitialState() != None:
                    self.addStatesToEnter(s.getInitialState(), s, statesToEnter, statesForDefaultEntry)
                else:
                    # @TODO: throw exception since compound states must have an initial state
                    assert(False)
                    
            # when entering a state we enter also the ancestors
            ancestors = s.getProperAncestors(root)
            for ancestor in ancestors:
                #if ancestor in statesToEnter == False:
                if scxml4py.helper.isStateInList(ancestor, statesToEnter) == False:
                    statesToEnter.append(ancestor)
                if type(ancestor) == StateParallel:
                    substates = ancestor.getSubstates()
                    for substate in substates:
                        if substate.isDescendantFrom(ancestor) == False:
                            self.addStatesToEnter(substate, ancestor, statesToEnter, statesForDefaultEntry)


    def setModel(self, theStateMachine):
        self.mStateMachine = theStateMachine
        
    def setContext(self, theContext):
        self.mContext = theContext
        
    def setEventHandlingPolicy(self, policy):
        assert(policy >= EventHandlingPolicy.SILENT)
        assert(policy <= EventHandlingPolicy.DEFFERRED)
        self.mEventHandlingPolicy = policy
            
    def addEventListener(self, eventListener):
        assert(eventListener != None)
        self.mEventListeners.append(eventListener)
        
    def removeEventListener(self, eventListener):
        assert(eventListener != None)
        self.mEventListeners.remove(eventListener)
        
    def removeAllEventListener(self):
        self.mEventListeners.clear()

    def notifyEventListeners(self, theEvent):
        for l in self.mEventListeners:
            l.notify(theEvent)
    
    def addStatusListener(self, statusListener):
        assert(statusListener != None)
        self.mStatusListeners.append(statusListener)
        
    def removeStatusListener(self, statusListener):
        assert(statusListener != None)
        self.mStatusListeners.remove(statusListener)
        
    def removeAllStatusListener(self):
        self.mStatusListeners.clear()
    
    def notifyStatusListeners(self, theStatus):
        for l in self.mStatusListeners:
            l.notify(theStatus)
