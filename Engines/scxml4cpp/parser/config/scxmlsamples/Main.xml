<?xml version="1.0" encoding="us-ascii"?>
<!-- A wrapper state that contains all other states in this file
- it represents the complete state machine --> <scxml xmlns="http://www.w3.org/2005/07/scxml"
       version="1.0"
       initial="Main"
       profile="ecmascript">
  <state id="Main">
    <!-- its initial state is Test1 -->
    <initial>
      <transition target="Test1"/>
    </initial>

    <!-- Really simple state showing the basic syntax. -->
    <state id="Test1">
      <initial>
        <transition target="Test1Sub1"/>
      </initial>
      <!-- Runs before we go into the substate -->
      <onentry> 
        <log expr="'Inside Test1'"/>
      </onentry>

      <!-- Here is our first substate -->
      <state id="Test1Sub1">
        <onentry>
          <log expr="'Inside Test1Sub1.'"/>
        </onentry>
        <onexit>
          <log expr="'Leaving Test1Sub1'"/>
        </onexit>
        <!-- Go to Sub2 on Event1 -->
        <transition event="Event1" target="Test1Sub2"/>
      </state>

      <!-- Here is the second substate 
           It is final, so Test1 is done when we get here -->
      <final id="Test1Sub2"/>

      <!-- We get this event when we reach Test1Sub2. -->
      <transition event="Test1.done" target="Test2"/>

      <!-- We run this on the way out of Test1 -->
      <onexit>
        <log expr="'Leaving Test1...'"/>
      </onexit>
    </state>

    <state id="Test2">
      <initial>
        <transition target="Test2Sub1"/>
      </initial>

      <!-- This time we reference a state 
           defined in an external file.  Note that we could have
           loaded the entire file by leaving off the #Test2Sub1,
           but in that case we would need to rename one of the
           Test2Sub1 states (here or in the external file) to
           avoid the name collision -->
      <state id="Test2Sub1" src="External.scxml#Test2Sub1"/>
  
      <final id="Test2Sub2"/>

      <!-- Test2Sub2 is defined as final, so this
           event is generated when we reach it -->
      <transition event="Test2.done" next="Test3"/>
    </state>

    <state id="Test3">
      <initial>
        <transition target="Test3Sub1"/>
      </initial>

      <state id="Test3Sub1">
        <onentry>
          <log expr="'Inside Test3Sub1...'"/>
          <!-- Send our self an event in 5s -->
          <send event="'Timer'"  delay="'5s'"/>
        </onentry>
        <!-- Transition on to Test4.
             This will exit both us and our parent. -->
        <transition event="Timer" target="Test4"/>
        <onexit>
          <log expr="'Leaving Test3Sub1...'"/>
        </onexit>
      </state>

      <onexit>
        <log expr="'Leaving Test3...'"/>
      </onexit>
    </state>
    
    <state id="Test4">
      <onentry>
        <log expr="'Inside Test4...'"/>
      </onentry>
      <initial>
        <transition target="Test4Sub1"/>
      </initial>

      <state id="Test4Sub1">
        <onexit>
          <log expr="'Leaving Test4Sub1...'"/>
        </onexit>
        <!-- This transition causes the state to exit immediately
             after entering Test4Sub1.  The transition has no event
             or guard so it is always active -->
        <transition target="Test5"/>
      </state>
    </state>
       
    <state id="Test5">
      <onentry>
        <log expr="'Inside Test5...'"/>
      </onentry>
      <initial>
        <transition target="Test5P"/>
      </initial>

      <!-- Fire off our parallel states -->
      <parallel id="Test5P">
        <final id="Test5PSub1"/>
        <final id="Test5PSub2"/>
        <onexit>
          <log expr="'all parallel states done'"/>
        </onexit>
      </parallel>

      <!-- The parallel states are all final, so this
           event is generated immediately.  Although not shown,
           compound states (i.e., <state>s with content)
           are permitted within <parallel> as well. -->
      <transition event="Test5P.done" target="Test6"/>
    </state>

    <!-- 
         - This state shows invocation of an external component.
         - We will use CCXML + VoiceXML actions as an example 
         - as it is a good smoke test to show how it all 
         - fits together. 
         - Note: In a real app you would likely 
         - split this over several states but we 
         - are trying to keep it simple here. 
    -->
    <state id="Test6"
           xmlns:ccxml="http://www.w3.org/2002/09/ccxml"
           xmlns:v3="http://www.w3.org/2005/07/vxml3">
      <datamodel>
        <data name="ccxmlid" expr="32459"/>
        <date name="v3id" expr="17620"/>
        <data name="dest" expr="'tel:+18315552020'"/>
        <data name="src" expr="'helloworld2.vxml'"/>
        <data name="id" expr="'HelloWorld'"/>
      </datamodel>

      <onentry>
        <!-- Use <send> to run a createcall using the 
             CCXML component / Event I/O Processor -->
        <send target="ccxmlid" type="'ccxml'" event="'ccxml:createcall'" namelist="dest"/>
      </onentry>

      <transition event="ccxml:connection.connected">      
        <!-- Here as a platform-specific extension we use example V3 
             Custom Action Elements instead of send. -->
        <v3:form id="HelloWorld">
          <v3:block><v3:prompt>Hello World!</v3:prompt></v3:block>          
        </v3:form>
      </transition>

      <transition event="v3:HelloWorld.done">
        <!-- Here we are using the low level <send> 
             element to run a v3 form. Note that the event "v3:HelloWorld.done" 
             is assumed either to be set/sent explicitly by the v3:form code or 
             implicitly by some process outside of the v3:form -->
        <send target="v3id" type="'v3'" event="'v3:formstart'" namelist="src id"/>
      </transition>

      <transition event="v3:HelloWorld2.done">
        <!-- we use _event.data to access data in the event we're processing.
             Again we assume the v3:HelloWorld2.done is set/sent from outside
             this document -->
        <ccxml:disconnect connectionid="_event.data.connectionid"/>      
      </transition>

      <transition event="ccxml:connection.disconnected" target="Done"/>
  
      <!-- Now some transitions to handle events generated by the component -->

      <transition event="send.successful">
        <!-- Component invoked successfully. This transition has no target 
             so Test6 is not exited.
             We are just going to log that we were able to send an event. -->
        <log expr="'Event was able to be sent'"/>
      </transition>

      <transition event="error.send" target="Done">
        <!-- If we get an error event we move to the Done state that 
             is a final state. -->
        <log expr="'Sending to and External component failed'"/>
      </transition>

      <onexit>
        <log expr="'Finished with external component'"/>
      </onexit>
    </state>

    <!-- This final state is an immediate child of Main
         -  when we get here, Main.done is generated. -->
    <final id="Done"/>
    <!-- End of Main > -->
  </state>
</scxml>
